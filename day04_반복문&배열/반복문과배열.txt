for문 질문할 때는 스프레드시트를 만들어서 이해를 노력해보고, 그럼에도 못했을 때 질문할 것.

for 문 

for ( 초기식; 조건문; 증감식 ) {
반복 시행
}


1. 반복문
	1-1. while 문
		-while문 역시 for문과 마찬가지로 반복적인 처리를 수행하는 문법
		-for문은 초기식, 조건식, 증감식을 모두 내장하는 반면, while문은 조건식만을 내장하기 때문에 
		초기식과 증감식을 외부에 따로 정의해 주어야 한다.


	//while 문의 기본 구성
	while(조건식) {
		.. 반복적으로 동작할 구문..
	}


	//while 문의 이용
	초기식 ;
	while(조건식) {
		..반복적으로 동작할 구문..
		증감식
	}

	//while 문의 예제
	int i = 1;
	while (i<=10) {
		sum+=i;
		i++
	}


	1-2. do~while 문 	// 거의 안쓰임 ( 이론상으로만 존재함 )
		- 조건의 판별을 나중에 수행하는 반복문 형태
		- 초기식을 설정한 후 do{...} 안에 문장을 우선적으로 1회 실행하고 조건을 판별하므로,
		조건이 참이 아니더라도 최소 1회는 실행된다.

	//do ~ while 문의 기본 구석
	초기식;
	do {
	... 반복적으로 동작할 구문 ...
	증감식;
	} while (조건식) ;


	1-3. 무한 루프
		- 증감식이 설정되지 않거나, 증감식이 수행되더라도 조건식이 거짓이 되지 않는 형태
		- 조건식이 항상 참이므로, 반복문이 종료되지 않는다.
		- 프로그램이 PC의 자원을 매우 많이 사용하게 되므로, 시스템 다운을 발생시킬 수 있다.
	
	//for문의 무한루프 예시
	for(int i = 0; i < 10; i--) {
		System.out.println(i);
	}


	이렇게 하면 무한으로 감소하는 i값을 구경할 수 있음. ex)로또가 당첨될 때 까지 돌리는 시스템에서 쓰임(적절한 퇴장 구문이 있으면 쓸 수 있음)

	//while문의 무한루프 예시
	while(true) {
		System.out.println("Hello");
	}


2. 변수의 범위
	2-1. 변수의 범위 (= 변수의 스코프)
		- 자신보다 하위 블록으로 침투할 수 있다.
		
		int num = 100;
		if (num == 100) {
			// num이 현재 블록의 바깥에서 선언되었으므로 유효
			System.out.println(num);
		}

------------------------------------------------------------------------
		int num = 100;
		for(int i=0; i<10; i++) {
			// 변수 num이 현재 블록 밖에서 생성되었으므로 사용가능
			System.out.println(num+i);
		}

========================================================================

		- 자신이 선언된 블록 밖으로는 빠져나갈 수 없다.

		int num = 100;
		if(num == 100) {
			int result = num + 100;
		}
		System.out.println(result); 	//에러발생 : 변수 result가 if블록 안에서 생성되었으므로 사용 불가

-------------------------------------------------------------------------

		for( int i = 0; i <= 10; i++) {
			...	
		}
		System.out.println(i);		//에러발생 : 변수 i 가 for문 블록 안에서(시작문도 블록 안으로 취급) 생성되었으므로 사용 불가
						// i가 for문을 위한 괄호 안에서 사용되었으므로 사용 불가(위와 같은 말)

=========================================================================

		- 블록 안에서 선언된 변수는 블록 밖에서 존재하는 동일한 이름의 변수와는 이름만 동일할 뿐,
		다른 값으로 인식된다.

		int target = 100;
		if(target == 100) {
			int num = target + 100;
		} else {
			int num = target - 100; 		// int 문 밖으로 나오면서 ( 다른 블록이기 때문에) 중복 선언이 아니게 됨.
		}


3. 여러가지 문법의 중첩 사용
	- 앞서 살펴본 문법들은 서로 중첩해서 사용하는 것이 가능
	* 이중 for문은 어려워서 나중에 다시 배우기로 함!



 4. 반복문에서의 break와 continue
	- break : 반복문 안에서 break 키워드를 만나면 반복을 강제 종료
	- continue : 실행 흐름이 증감식으로 강제 이동 ( 아래에 있는 구문으로 가지 않고 바로 위에 있는 증감식으로 이동 )





5. 배열 
	5-1. 배열이란?
		- 변수를 그룹으로 묶은 형태의 한 종류로서, 사물함같은 형태를 갖고 있다.
		- 하나의 배열 안에는 같은 종류(데이터 형)의 값들만 저장될 수 있다.
		
	5-2. 배열을 만드는 방법
		- 배열의 선언
			데이터형[] 배열이름;
		- 배열의 생성 - 변수를 저장할 수 있는 사물함을 생성
			배열이름 = new 데이터형[크기];

		- 배열의 생성의 예
			int[] grade;
			grade = new int[3];

		- 배열의 선언과 크기 지정에 대한 일괄처리
			데이터형[] 배열이름 = new 데이터형[크기];
			int[] grade = new int[3];				//데이터형 : int, 배열이름 : grade, 크기 : 3

	5-3. 배열의 모양
		- 생성된 배열은 사물함과 같이 각각의 칸에 값들이 저장되고, 각각의 칸은 0부터 일련번호가 지정된다.
		(일련번호 = 배열의 인덱스)

	5-4. 배열의 값을 저장하기
		- 배열은 값을 저장할 수 있는 공간일 뿐, 그 자체가 값은 아니다.	
		- 값이 대입되지 않은 경우, 숫자형은 0, boolean 형은 false 가 자동으로 대입된다.
		- 배열 안에 값을 저장하기 위해서는 인덱스 번호를 사용하여 각각의 칸에 직접 값을 대입해야 한다.

			배열이름[인덱스] = 값;	//배열에 값을 대입하는 방법

		- 둘리의 점수를 배열로 표현
			int[] grade = new int[3];
			grade[0] = 75;
			grade[1] = 82;
			grade[2] = 91;

		- 배열의 크기 설정과 값 할당에 대한 일괄처리
			-> 배열의 크기를 지정하면(?) 괄호"{...}" 안에 배열에 포함될 각 항목들은
			콤마(,)로 나열하면, 배열의 생성과 값의 할당을 일괄처리할 수 있다.
			이 때,배열의 크기를 별도로 지정하지 않으며, "new 데이터형[]" 부분은 생략

		데이터형[] 배열이름 = new 데이터형[] {값1, 값2, 값3, ... , 값n} 		// 길이가 값의 수 만큼 자동으로 정해지며, 동시에 값까지 할당이 됨.


		데이터형[] 배열이름 = {값1, 값2, 값3, ... , 값n}				// 이미 선언되어 있는 배열에, 값을 할당하기


	5-5. 배열값 사용하기
		- 배열 안에 저장되어 있는 값들을 사용하여 연산이나 출력등의 처리를 위해서는 배열에 부여된 인덱스 값을 통해서 데이터에 접근해야 한다.

		System.out.println(grade[0]);
		System.out.println(grade[1]);
		System.out.println(grade[2]);
		System.out.println(grade[3]);		//에러 발생 : grade[3] 의 자리가 없기 때문

	5-6. 배열과 반복문
		- 배열의 특성
			: 0~(배열 크기 - 1) 만큼의 인덱스 값을 순차적으로 갖는다.
		- 특성을 활용한 배열 데이터의 처리
			: 일정 범위를 갖고 순차적으로 증가하는 인덱스 값의 특성을 활용하면 반복문 안에 배열의 값을 할당하거나, 할당된 값을 읽어들이는
			처리가 가능하다.


			for ( int = 0; i < 3; i++ ) {
				System.out.println(grade[i])
			}


	5-7. 배열의 크기(길이)
		-배열의 길이를 얻기 위해서는 "배열이름.length" 형식으로 접근한다.
		int size = grade.length;





6. 2차원 배열
	6.1 배열의 종류
		-1차 배열
			-> 앞에서 살펴본 배열처럼 한 줄만 존재하는 사물함같이 구성된 배열
			-> 행에 대한 개념이 없고, 열에 대한 개념만 존재하기 때문에 "배열이름.length"는 몇 칸인지를 알아보는 기능이 된다.

		-2차 배열 				//실무에서 사용하는 범위는 2차까지.
			-> 1차 배열을 쌓아 둔 느낌. 행의 개념 추가.
			-> 1차 배열의 각 칸에 새로운 배열을 넣는 형태
			-> 1차 배열의 각 칸은 행이 되고, 각각의 칸에 추가된 개별적인 배열이 "열"의 개념이 되어
			"행렬"을 구성하게 된다.


		-다차원 배열
			-> 배열의 각 칸에 지속적으로 다른 형태의 배열을 포함시키는 형태로서 2차, 3차, 4차, n차까지
			무제한으로 확장할 수 있다.
			-> 실무에서는 2차원 배열을 초과하는 형태는 사용하지 않는다.





	6-2. 2차원 배열의 선언
		- 데이터 타입의 이름 뒤에 대괄호"[][]"를 행과 열에 대하여 각각 지정한다.
			데이터형[][] 배열이름;					//데이터형 선언

		- 2차원 배열의 크기 할당
			-> 행과 열에 대한 크기를 명시한다.	
			배열이름 = new 데이터형[행][열];				//배열 크기 명시

		- 2차원 배열의 선언과 할당의 일괄처리
			데이터형[][] 배열이름 = new 데이터형[행][열];		//데이터형 선언 및 크기 할당
										//index 규칙은 항상 같음. 0,1,2,... length-1. 주의!!!
	----------------------------------------------------------------------------------
			int[][] grade = new int[3][3];

	6-3. 2차원 배열에 대한 값의 대입 방법
		- 행, 열에 대한 인덱스를 통합하여 값을 대입한다.
			배열이름[행][열] = 값; 

	6-4. 일괄 지정하는 방법
		int[] [] grade = new int[][]{
			{75, 82, 91},
			{88, 64, 50},
			{100, 100, 90}
		};


	6-5. 2차원 배열의 길이
		- 2차원 배열의 길이는 해에 대한 측면과 열에 대한 측면을 나누어서 생각해야 한다.
		- 행의 길이
			int rows = grade.length;			//행의 길이 
		- 열의 길이
			int cols = grade[행].length;		//행에 따라 열의 길이가 달라질 수 있음. 진짜 이상하게 만들면 1행 : 3항, 2행 : 1항, 3행 : 2항, 이런식으로 만들수도 있음


































오늘 할 일 : 
반복문, 문제풀기, 변수의 중첩, 배열(시간되면)
벨로그 topic : LCS?