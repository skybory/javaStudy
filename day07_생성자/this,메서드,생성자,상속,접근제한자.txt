1.this

  1-1. 현재 클래스의 메서드를 의미하는 용도로서의 this
	
	class User {
		public String getName() {
			String name = "자바학생";
			return name;
		}
	
		public void sayName(){
			String myname = this.getName();		//this가 없어도 문제가 되지 않음. 다만, 같은 클래스에 있는 메서드라는 강조의 의미.
			System.out.println(myname);
		}

	}
 - getName() 메서드는 this 키워드를 사용하여 현재 클래스 안에 포함된 다른 메서드임을 명시하고 있다.
 - 하지만 메서드의 경우, 다른 클래스의 메서드를 이름만으로 호출할 수 있는 방법이 없기 때문에, this.getName() 이 아닌,
getName()만 사용하더라도 코드 가독성의 문제는 없다.


드래그 대충 + Ctrl + / = 전체주석 (메모한적있음)

2. 용어정의
  - 클래스 	: 객체를 만들어 내기위한 설계도
  - 객체		: 구현할 대상
  - 인스턴스	: 설계도를 바탕으로 구현된 구체적인 실체

	class Animal{ ... }
	public class Main{
		public static void main(String[] args){
			Animal cat;		// 여기까진 cat을 객체라고 부름
			//인스턴스화
			// cat 은 Animal 클래스의 '인스턴스' 라고 함
			// 객체를 메모리에 할당하면 '인스턴스'
			cat = new Animal();	// 이 작업을 '인스턴스화' 라고 함. cat 이 인스턴스가 됨.
		}
	}

  - 클래스 vs 객체 :
	-> 클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상'을 의미
  - 객체 vs 인스턴스 : 
	-> 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어
실제 사용될 때 인스턴스라고 부른다.
	-> '인스턴스화 하여 레퍼런스를 할당한' 객체를 '인스턴스' 라고 말하지만,
	 엄격하게 객체와 인스턴스를 나누긴 어렵다.

  - 멤버변수, 전역변수 = 필드(field)
  - 지역변수

3. 클래스, 메서드, 상수의 이름규칙
  - 공통적인 이름 규칙
	-> 영어+숫자+언더바(_)의 조합으로 사용, 첫 글자는 반드시 영어로 표기
  - 클래스 이름 규칙
	-> 첫 글자는 대문자로 시작, 나머지 글자는 소문자로 표시
	-> 두 개 이상의 단어를 조합해야 할 경우, 새로운 단어는 대문자로 시작한다.
		class Member
		class MyClass
		class NetworkHelper

  - 메서드, 변수이름 규칙
	-> 대부분 소문자로 구성되지만, 두 개 이상의 단어를 조합할 경우 새로운 단어는
	대문자로 표시한다. -> 가독성을 높이고, 유지보수를 쉽게 하기 위함.
		int age;
		String username;		//지양하는 이름
		String userName;	//지향하는 이름
		String membercount;	//지양하는 이름
		String memberCount;	//지향하는 이름
		String member_count;	//언더바를 이용한 띄어쓰기

  - 상수 이름 규칙
	-> 모두 대문자로 표시한다.
	final double PI = 3.14;
	final int COLOR;

4. 생성자
  4-1. 생성자란?
  - new 키워드를 사용하여 객체가 생성될 때 자동으로 실행되는 특수한 형태의 메서드.
  - 리턴형을 명시하지 않으며, 메서드의 이름은 클래스와 동일하다.
  
	class User{
		User(){
			//생성자
			//이 안은 객체가 생성될 때 자동으로 호출
		}
	}

	User u = new User();
 - 자동으로 실행된다는 특성 때문에, 객체가 생성되면서 해당 객체의 특성을 초기화하기 위하여 사용된다.
(ex : 멤버변수의 초기값을 할당하는 용도)

 4-2. 기본 생성자
  - 파라미터가 없는 생성자
  - 클래스에 특별히 생성자가 정의되지 않은 경우 java컴파일러는 기본 생성자가 존재한다고 인식한다.

	class User{
		User() {			// 기본 생성자
						// 생성자는 있지만, 내용이 비어있다.
		}
	}

 4-3. 파라미터를 갖는 생성자
  - 생성자도 메서드의 한 종류이므로 파라미터를 함께 정의하는 것이 가능하다.
  - 생성자의 파라미터를 멤버변수에 복사하는 것으로 객체의 초기화를 외부적인 요인에 의해 처리할 수 있다.

	class User{
		String name;
		int age;

		User(String name, int age) {		// 리턴 타입이 없을 뿐, 파라미터를 받아올 수 있다.
			this.name = name;		// field값(=전역변수,멤버변수)에 지역변수 name 대입
			this.age = age;			// 생성자 파라미터값을 field에 복사(위와 같음)
		}
	}
---------------------------------------------------
	// 생성자에 파라미터가 정의된 경우, 객체 생성 구문에서
	// 해당 파라미터를 전달해야 한다.
	User u = new User("자바학생" , 20); 		// 파라미터값이 없으면 에러가 생김.
							// 생성자 파라미터는 개발자의 의도가 드러남.


5. 은닉성
  5-1. 은닉성
  - 멤버변수나 메서드가 객체에 노출되지 않도록 설정하는 기법
  - 객체를 사용하는 측의 실수로 인한 기능의 오작동을 방지하기 위해, 클래스의 일부를 숨기는 처리를 말한다.	//접근 한정자를 사용해 캡슐화함
 
 5-2. 적용방법
  - 변수의 이름이나 메서드 이름 앞에 "접근 한정자"를 지정한다.
	
	접근 한정자 ( 제한 정도 : public < protected < defalt < private )
	public
		-> 모든 곳에서 접근 가능하다
		-> 일반적으로 모든 메서드 앞에 명시한다.	
	private
		-> 클래스 안에서만 사용 가능하고, 객체를 통해 접근할 수 없다.
		-> 일반적으로 모든 멤버변수 앞에 명시한다.

	protected
		-> 현재 클래스 내의 다른 자원이나, 같은 패키지 안에 존재하는 클래스와 하위 클래스에서 접근 가능하다.
		-> 잘 사용하지 않는다.
	default
		-> 접근 한정자를 명시하지 않은 경우
		-> 현재 클래스 내의 다른 자원이나 동일 패키지 내의 다른 클래스에서 접근 가능하다.
		-> 잘 사용하지 않는다.

설명 : private으로 다 잠궈 둔 다음에, public으로 잠긴 method를 이용해 class 내부의 멤버변수를 수정한다.




 5-3. getter, setter
  - 멤버 변수가 은닉된 형태로 선언된 경우, 프로그램의 가장 근본적인 데이터에 접근하는 방법이 사라지므로, 메서드를 통하여
간접적으로 접근하는 방법이 마련되어야 한다. 
  - getter, setter는 은닉된 멤버변수에 간접적으로 접근하기 위하여 정의된 메서드들을 의미하는 용어

	-> getter : 은닉된 멤버변수의 값을 리턴하기 위한 메서드
	-> setter : 파라미터로 전달된 값을 멤버변수에 복사하기 위한 메서드


 5-4. 클래스에 접근 한정자를 지정한 경우

	접근 한정자
	public
		-> 객체 생성 가능.
		-> 서로 다른 소스코드에 정의된 클래스끼리도 객체 생성이 가능하다.

	private
		-> 클래스에 적용할 수 없다.

	protected
		-> 클래스에 적용할 수 없다.

	default
 		-> 지금까지의 예제 형태
		-> 동일한 소스코드에 정의된 클래스끼리만 객체로 생성가능.

 5-5. 클래스의 분리
  - 하나의 소스코드에서 프로그램의 모든 기능을 구현하게 되면 유지보수에 비효율적이므로, 기능단위로 소스코드를 분리해야 한다.
  - 소스코드가 분리된 클래스끼리는 public이 명시되어야만 서로 객체 생성이 가능하다.
  - 일반적으로 클래스 정의에는 public 접근 한정자만 사용한다.
  - 하나의 소스 코드에는 하나의 public 클래스만 존재할 수 있다.

 5-6. 자바빈즈(Java Beans)
  - 자바 언어에서 사용하는 복합적 데이터 표현의 최소단위로써, 재사용이 가능한 컴포넌트(구성요소)를 생성할 수 있다.
  - 자바빈즈 클래스로서 작동하기 위해서, 객체 클래스는 명명법, 생성법, 그리고 행동에 관련된 일련의 관례를 따라야만 한다.
  - 지켜야 할 관례
	-> 클래스는 생성자를 가지고 있어야 한다.
	-> 클래스의 속성들은 get, set 혹은 표쥰 명명법을 따르는 메서드들을 사용해 접근할 수 있어야 한다. 


6. 상속성
 6-1. 상속이란?
  - 클래스간의 상속
  - 클래스간에는 부모 - 자식의 상속 관계를 설정할 수 있다.
  - 부모 클래스A를 자식 클래스B가 상속받을 때, B는 A의 모든 멤버변수와
 메서드를 자신의 것으로 상속받게 된다.
( 단, private으로 설정된 기능은 상속되지 않는다.)
 - B는 A의 public, protected 기능들을 직접적으로 코딩하지 않더라도
 자신의 것으로 사용할 수 있게 된다.

 6-2. 상속 정의 방법
  - extends 키워드를 사용하여 부모 클래스의 이름을 명시한다.

	public class 자식클래스 extends 부모클래스 {...}

 6-3. 클래스 다이어그램을 통한 상속의 표현
  - 클래스의 구조를 표현하는 클래스 다이어그램에서, 상속은 자식 클래스가 부모클래스를 가리키는 화살표로 표현한다.
  - 상속관계가 이루어질 때 부모 클래스를 super 클래스라 한다.
 
 6-4. 상속의 활용
  - 기존에 존재하는 클래스의 소스 수정 없이 기능을 확장하고자 하는 경우
  - 여러개의 클래스에서 공통되는 기능을 추출하여 공유하기 
	-> 이와 같이 공통 기능을 별도의 클래스로 추출해내면, 코드의 재사용 및 수정이 용이하다.















