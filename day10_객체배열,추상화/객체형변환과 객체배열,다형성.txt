1. 객체 형변환과 객체 배열
 1-1. 객체 형변환
  - java 기본 유형의 데이터들처럼 객체참조변수의 경우에도 형변환(casting)이 이루어진다.
  - 서로 다른 클래스 유형으로부터 나온 객체 참조변수들간의 대입에는 일정한 규칙이 있다.

	Parent parent = new Child();

 - 왼쪽 항(Parent)과 오른쪽 항(Child)의 객체 유형이 서로 다른 경우, 두 유형이 서로 상속 관계에 있고 왼쪽 객체(Parent)가
오른쪽 객체(Child)의 상위 클래스인 경우에만 암묵적인 형 변환이 일어난다.

  - 하위 클래스에서 상위 클래스 유형으로 할당하는 것은 가능하나, 그 반대의 경우에는 명시적 형변환을 해야한다.
	-> 그러나 상위 클래스 유형을 하위 클래스 유형으로 강제 형 변환하는 경우에는 할당되는 객체의 유형에 따라서 실행 오류가
	발생할 수 있다.

 1-2. 객체간의 암묵적 형변환

C -> B
Y -> X
B,X -> A

  - 클래스간의 상손관계가 
왼쪽이 부모! 오른쪽이 자식!
	A a1 = new B();

왼쪽이 부모! 오른쪽이자식! 이므로, 암묵적 형변환이 가능하다.

아래는 전부 다 가능한 케이스들이다.
	A a1 = new B(); 가능
	A a2 = new X(); 가능
	A a3 = new C();	가능
	B b1 = new C();	가능

	C c = new c();
	B b = c; 	가능!
			만들어진 인스턴스에 부모 클래스를 할당하는 것으로 암묵적 형변환이 가능.

	Y y = new Y();
	X x2 = y;		가능!

 1-3. 암묵적 형변환과 메서드 오버라이드
  - 암묵적 형변환은 부모를 상속받는 자식객체의 기능을 부모에게 물려받은 기능만 사용하도록 제한한다.
  - 그러므로 암묵적 형변환이 발생하게 되면 오버라이드된 기능만 사용가능하고, 추가적으로
구현한 기능은 사용할 수 없다.
  - 주의할 점은 기능의 제한이지 기능의 변경은 아니라는 것이다.


 1-4. 명시적 형변환의 필요성

  - 상속관계의 객체를 부모 형태로 변환하면 클래스의 종류를 구분하지 않고 일관된 기능을
 호출할 수 있고, 객체가 상위 클래스형태로 형변환 되더라도 Override된 자신의 기능은 잃지 않는다.
  - 하지만, 추가적으로 구현한 기능은 사용할 수 없게 되므로 원래의 기능을 다시 사용할 수 있는
방법이 필요해졌다.

	Unit u1 = New Army();
	Unit u2 = New Navy();
	Unit u3 = New AirForce();

	u1.attack();
	u2.attack();
	u3.attack();... 	//반복문을 써서 한꺼번에 처리 가능

 1-5. 명시적 형변환
  - 부모클래스의 객체를 자식 클래스 형태로 변환하는 것
  - 형변환을 위해서는 다음과 같이 형변환할 클래스 이름을 명시적으로 지정해 주야한다.
  
	ChildClass c = (ChildClass) parent;

 1-6. 명시적 형변환의 조건
  - 객체가 최초 생성될 때 자식 클래스형태로 생성되고, 부모 형태로 암묵적 형변환이 된 상태를
  다시 원래의 자식 클래스 형태로 되돌릴 경우에만 가능하다.

	ChildClass c1 = new ChildClass();
	ParentClass p = c1;			-->여기까지가 암묵적 형변환.
	ChildClass c2 = (ChildClass)p;		-->여기부터


 1.7 명시적, 암묵적 형변환 가능여부

	Army army1 = new Army();		//Army 객체 army 생성
	Unit u = army1;			// Unit u 에 army 할당. 암묵적 형변환
	Army army2 = (Army)u;		// 명시적 형변환.

	Unit u = new Navy();		//왼쪽에 부모, 오른쪽에 자식 : 암묵적 형변환	
	Navy navy = (Navy) u;		//명시적 형변환 가능.
	
	Unit u = new Unit();		//부모 클래스로 객체 생성 : 최초 객체 생성이 부모형태로 만들어진 경우는 불가능하다.
	Army army = (Army)u;		//부모를 자식으로 형변환(불가능)
					//문법상으로는 오류가 없으나, run을 하면 에러가 생김.

	Army army = new Army();		//자식 생성
	Unit u = army;			//암묵적 형변환 가능.
	Navy navy = (Navy)u;		//명시적 형변환 불가능.(army -> unit 은 가능하겠지만, navy -> unit 은 불가능하지않을까?)
		
	- 불가능 :
	최초 생성된 것과 다른 형식으로 변환하는 것은 불가능하다.

 - 위 두 경우 모두 문법적인 오류는 없기 때문에, 이클립스에서는 에러를 검출하지 못한다. 하지만
 프로그램 실행시 오류가 발생한다.


2. 객체배열
 2-1. 객체 배열
  - 일반 데이터 타입의 배열과 동일한 개념으로, 같은 클래스의 객체 여러개를 그룹화할 수 있다.
  - 일반 데이터형의 배열 생성과 객체 배열 생성 비교

	일반 데이터형 배열
	int [] data = new int[3];

	객체 배열	//데이터형 대신에 클래스이름을 써줌
	Army[] data = new Army[3];

  - 각 경우에 대한 배열의 요소 할당처리
	-> 일반 데이터형은 단순히 값을 대입하지만,
	객체 배열은 'new'를 사용하여 객체를 할당해야 한다.

	일반 데이터형 배열
	data[0] = 1;
	data[1] = 2;
	data[2] = 3;
	
	- 객체 배열의 경우
	data[0] = new Army();
	data[1] = new Army();
	data[2] = new Army();


 2-2. 정리
  - 객체 형변환
	-> 같은 부모 클래스에서 파생된 서로 다른 자식 클래스의 객체들은 부모 형태로 암묵적 형변환되어
	일괄된 형식으로 사용 가능하다.

  - 객체 배열
	-> 동일한 클래스의 객체는 배열로 묶어서 여러개를 한꺼번에 제어할 수 있다.

 2-3. 부모 클래스의 배열에 자식 클래스의 객체 넣기
  - 배열의 생성이 부모 클래스로 지정되었을 경우, 모든 자식 클래스의 객체들은 그 배열에 포함될 수 있다.

	Unit[] unit = new Unit[3];

	// 배열의 요소 할당 과정에서 암묵적 형변환이 이루어진다

	unit[0] = new Army();
	unit[1] = new Navy();
	unit[2] = new AirForce();

	unit 이라는 3칸짜리 배열을 만들었는데, 그 안에는
	자식 클래스의 new Army,Navy,AirForce가 들어갈 수 있음.


 2-4. 객체 배열 활용
  - 일괄 처리가 가능하다.
	-> 서로 다른 객체를 부모 형태의 배열에 담게 되면, 반복문으로 일괄처리가 가능하다.
	-> 이 때, 배열의 각 요소를 통해 사용하는 메서드가 Override되어 있을 경우, 부모의 메서드가 아니라 
	자신이 재정의한 기능을 뜻한다.


	for ( int i = 0; i < unit.length; i++) {
		unit[i].attack();
	}


 2-5. 객체 배열 활용2
  - 원래의 기능으로 복귀하기
	-> 배열의 각 요소가 확장한 기능을 사용하기 위해서는
	원래의 클래스 형태로 명시적 형변환이 이루어져야 한다.

	-> 하지만, 반복적으로 처리되는 과정에서 몇 번째 요소가
	어떤 클래스에서 최초 생성되었는지를 판단하기란 쉽지 않다.

  - instatnceof 연산자
	-> instanceof 연산자는 어떤 객체에 대한 출처를 판단하여 boolean 형으로 결과를 반환한다.

	if(unit[0] instanceof Army) {		// 객체비교는 instanceof. 값 비교는 ==.  unit[0]가 Army출신의 객체(인스턴스)야??? 라는 질문.
		Army temp = (Army)unit[0];		// 명시적 형변환 
	}



 3. 추상화
 3-1. 상속성과 다형성의 필요성
  - 상속성은 객체간의 공통적인 기능을 관리하기 위한 기법으로 코드의 재사용을 통하여 프로그램의 유지보수를 편리하게 한다.
  - 다형성(Override, Overload) 은 서로 다른 기능이지만 메서드의 이름을 공통되게 처리함으로써 전체 프로그램의 일관성을 유지하게 한다.

 3-2. Override 처리의 문제 발생 가능성
  - @Override 키워드를 사용하지 않고 메서드를 재정의하는 과정에서 메서드 이름에 실수가 발생하더라도 에러가 아닌
 새로운 메서드의 정의로 인식되므로, 의도하지 않은 실행결과를 가져올 수 있다.

  - @Override키워드를 사용하더라도 자식 클래스를 구현하는 개발자의 실수로 인하여 부모의 기능을 재정의하지 않았다면
 다형성의 구현은 이루어지지 않게된다.

 3-3. 상속처리 시, Override 강제하기
  - 추상화 기법은 특정 클래스를 상속받은 경우, 부모의 특정 메서드들을 무조건 재정의하도록 강제하는 기법이다.
  - 특정 메서드를 재정의하도록 강제함으로써, 자식 클래스들을 작성하기 위한 가이드 역할을 할 수 있다.
  - 즉, 추상화 기법은 Java 클래스를 작성하기 위한 설계도를 소스코드 형태로 제시하는 역할을 한다.



 3-4. 추상 메서드 만들기
  - 추상 메서드를 정의하기 위해서는 'abstract' 키워드를 사용하여 메서드를 정의한다.
  - 추상 메서드는 자식 클래스가 구현해야 하는 메서드의 가이드라인만 제시하기 위한 목적으로 사용되기 때문에, 
 선언만 가능하고 구현부가 없다.

	public void sayHello() { ...//여기가 구현부! };

여기에 abstract를 추가하면
	//추상메서드(이게 하나라도 있으면 추상클래스가 됨)
	public abstract void sayHello();			// 구현부가 사라짐

 3-5. 추상 메서드를 포함한 클래스
  - 추상 메서드를 하나 이상 포함하고 있는 클래스는 반드시 '추상 클래스'로 정의되어야 한다.
  - 추상 클래스는 abstract 키워드를 사용하여 정의할 수 있다.


// 추상 클래스의 정의
public abstract class Hello{
	public abstract void sayHello();	
}

  - 추상 클래스는 객체를 생성할 수 없고, 반드시 상속을 통해서만 사용될 수 있다. 즉, 추상 클래스는 다른 자식 클래스를
 위한 '가이드라인'의 역할을 한다.





4. 인터페이스
  - 추상클래스인 Unit의 기능을 용도별로 분할하여 나누어 놓고, 주인공과 몬스터가 각각 기능중에서 자신에게 필요한 것들만
상속받도록 하는 방법을 필요로 한다.

 4.1 추상클래스의 한계

 - 자바 클래스간에 상속에서는 하나의 부모만 존재할 수 있기 때문에, 앞의 상황에서 요구하는 다중 상속의 구현은 불가능하다.


 4-2. Interface란?
  - 완벽한 추상화를 구현하기 위한 Java Class의 한 종류
  - 다중 상속이 가능하기 때문에 용도별로 세분화하여 필요한 요소만 상속할 수 있다.



  - 추상클래스
	-> 멤버변수, 생성자, 메서드, 추상메서드를 포함할 수 있다.
	-> 이 클래스를 상속받는 자식 클래스는 다른 클래스를 상속받을 수 없다. (하나의 클래스만 상속할 수 있음)
	-> 객체 생성이 불가능하다.

  - 인터페이스
	-> 객체의 생성이 불가능하다.
	-> 추상 메서드만 포함할 수 있다. (진짜 하는일이 없음. 가이드라인의 역할)
	-> 인터페이스는 다중 상속이 가능하다. ( 여러 클래스를 상속할 수 있음)





다음시간에 오면 워크스페이스를 새로 만들어보자.
수업용 워크스페이스 말고 따로 만들어보기.






