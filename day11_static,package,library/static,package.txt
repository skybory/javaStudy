1. static

public class Article {		//글번호, 제목, 날짜 --> 전체글수 + 카테고리 추가

	private int count;			//전체글수 추가
	private String category;		//카테고리 추가
	private int num;
	private String title;
	private String regDate;
}

똑같은 값을 가진 데이터를 활용하는 방법
Article.count 와 Article.category 를 나머지가 공유받아서 사용.
똑같은 데이터를 여러개 만들기 싫으니까!! --> static 이라는 키워드를 사용

  - 멤버변수는 모든 객체가 독립적으로 갖는 고유 데이터이기 때문에 게시물의 수 라는 공유 데이터를 모든 게시물이 갖게된다.
  - 즉, 각각의 객체가 중복된 데이터를 갖게 된다.
  - 총 게시물 수를 의미하는 count 변수의 경우, int 데이터 하나당 4byte 라는 점을 생각해 보면, 100개의 게시물이
  저장된 게시판일 경우 396byte의 메모리가 낭비되는 셈이다. 

 1-1. static 이해하기
  - 객체간의 공유 자원을 표현하는 static 키워드
  - 클래스를 설계할 때, 멤버변수 중 모든 객체에서 공통적으로 사용해야 하는 값에 static을 붙인다.

public class Article {		//글번호, 제목, 날짜 --> 전체글수 + 카테고리 추가

	private static int count;			//전체글수 추가  --> 스태틱 선언으로 공유하는 자원이 됨.
	private static String category;			//카테고리 추가
	private int num;
	private String title;
	private String regDate;
}

  - static이 붙은 멤버변수는 객체의 개수에 상관없이 단 하나만 생성되며, 이를 모든 객체가 공유하기 때문에
	메모리를 효율적으로 사용할 수 있다.

 1-2. 컴퓨터의 메모리 구조
  - 고정 영역
	- 코드 영역
	-> 프로그램의 코드가 저장되는 영역
	-> 이 영역에 저장된 명령어들을 CPU가 하나씩 가져가 실행한다.
	
	- 데이터 영역
	-> 전역변수와 static으로 선언되는 변수가 할당된다.
	-> 이 영역에 할당되는 변수들은 프로그램 시작과 동시에 메모리 공간이 할당되어 종료될 때까지 남아있게 된다.

  - 동적 영역
	- 힙 영역
	-> 프로그래머가 원하는 시점에 변수를 할당하고 소멸시키는 영역
	-> 메모리 동적 할당시 사용된다.
	-> 객체가 생성되는 영역이다.

	- 스택 영역
	-> 함수가 실행될 때 사용되는 파라미터와 지역변수에 대한 메모리 공간
	-> 함수의 종료와 함께 소멸된다. 

 1-3. 하나의 프로그램이 사용하는 메모리 영역

  - 고정 영역
	-> 프로그램이 실행되면 실행파일이 메모리에 로드되면서, 실행파일의 용량만큼 RAM을 사용한다.
	-> 실행 파일의 크기는 변할 수 없으므로, 이 영역의 크기는 고정 크기를 갖는다.

  - 동적 영역
	-> 프로그래머가 new 키워드를 사용해서 객체나 배열을 생성하면 사용된다. (힙 영역)
	-> 또 다른 경우는 메서드가 호출되는 동안 사용될 파라미터와 지역변수가 생성된다.(스택 영역)
	-> 메서드가 종료되거나 객체가 더 이상 사용되지 않으면 생성된 변수나 객체는
	메모리에서 사라지므로, 이 영역은 유동적인 크기를 갖게 된다.

 1-4. static 데이터의 생성위치
  - static 데이터는 메모리의 고정 영역중 데이터 영역에 생성되고, 일반 멤버변수나 객체는 동적 영역중 Heap
 메모리 영역에 생성이 된다.

 1-5. 프로그램이 메모리를 사용하는 순서
  - 최초 실행시 고정 영역에 실행파일만큼의 메모리를 점유 (프로그램을 실행시키는 최소 사양)
  - 프로그램이 각종 동작을 수행하는 동안 동적영역을 사용

 1-6. 멤버변수와 static 멤버변수의 차이
  - static 변수는 프로그램의 실행과 동시에 객체의 생성여부와 상관 없이 이미 존재하기 때문에 소스 코드에서는
 특정 클래스 안에 명시하지만, 그 클래스를 통해서 생성되는 객체나 그 안에 포함되는 멤버 변수와는 다른 존재이다.
  - 객체가 생성되지 않았더라도 이미 존재하고 있기 때문에, static 변수는 객체의 이름을 통해 접근하는 것이 아니라,
클래스의 이름을 통해 접근해야 한다.
  - 단, static 변수가 선언된 클래스 안에서는 변수 이름으로 접근이 허용된다.

 -> Article 클래스 및 다른 클래스에서 접근하는 경우
	Article.count = 3;			//특정클래스.스태틱변수
	Article.category = "공지사항";

-> Article 클래스에서 접근하는 경우
	count = 3;
	category = "공지사항";

 1-7. static 데이터에 접근하기 위한 메서드
  - 클래스에서 정의하는 일반 메서드들은 객체의 생성과 동시에 동적 메모리 영역에서 활성화된다.
	-> 동적 메모리 영역의 입장에서는 고정 메모리 영역의 자원들은 항상 존재
	-> 고정 메모리 영역의 자원들은 동적 메모리의 자원들이 항상 존재하는 것이라는 보장을 받지 못한다.	

  - 그러므로, 객체의 생성과 상관없이 static 변수에 접근하기 위한 메서드를 만들 필요가 있는데,
 메서드의 정의 과정에서 static 키워드를 사용하면 static 자원에 접근하기 위한 메서드를 만들 수 있다.

	public class Article {
		private static int count;
		public static void setCount(int count) {
			Article.count = count;
		}
		public static int getCount() {
			return Article.count;
		}	

	}	


 1-8. static 메서드 사용시의 제약사항
  - 메모리 영역의 차이 때문에 static 메서드는 동적 메모리 영역의 멤버변수를 사용하거나, static이 아닌
 일반 멤버함수를 호출할 수 없다.

	- 고정 영역
	-> static 변수와 static 멤버 함수가 생성된다.
	-> 이 영역의 자원들은 프로그램이 실행되는 동안 항상 존재한다.
	-> 동적 메모리 영역의 자원들은 항상 존재하는 것이 아니기 때문에 static 멤버함수는 동적 메모리 영역의 멤버변수를
 	사용하거나, static이 아닌 일반 멤버 함수를 호출할 수 없다.

	- 동적 영역
	-> 객체, 객체안의 멤버변수, 메서드, 메서드가 호출되었을 때 사용되는 지역 변수 등이 생성된다.
	-> 이 영역의 자원들은 생성과 제거가 유동적으로 반복된다.
	-> static 자원은 항상 존재하는 것이므로, 동적 영역에서는 static 변수를 활용하거나, static
	멤버함수를 호출할 수 있다.




디자인패턴

 2. SingleTon 디자인패턴  //헤드 퍼스트 디자인 패턴? = 책이름
  2-1. 디자인 패턴(Design Pattern)
  - 디자인 패턴이란, 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어나갈 것인가에 대한 일종의 솔루션같은 것이다.
  - 디자인 패턴은 설계자들이 "올바른" 설계를 "빨리" 만들어갈 수 있도록 도와준다.

 2-2. SingleTon 패턴
  - 프로그램 내의 여러곳에서 반복적으로 사용되어야 하는 객체에 대해 전역적인 범위를 갖도록 객체를 생성하고, 이 객체를
 여러 곳에서 공유하기 위한 클래스 작성 패턴.
  - 이러한 패턴을 통해 생성된 객체를 싱글톤 객체라고 한다.

 2-3. SingleTon 객체의 이점
  - 프로그램의 전역에서 활용할 재료로 사용되는 공유 기능을 하나만 생성하여 여러 곳에서 재사용함으로 해서 메모리를 효율적으로 사용할 수 있다.
  - 단 한번만 객체를 생성하면 다시 객체를 생성할 필요가 없기 때문에, 해당 기능을 사용할 때 마다 객체를 일일히 생성해야 하는 번거로움을
 피할 수 있다.

 3. Package
  - 패키지 -> 클래스에 대한 묶음 단위
  - 클래스를 용도별이나, 기능별로 그룹화한 것을 말한다.
  - 소스코드는 폴더로 분류된 형태로 존재하게 된다.
  - 서로 다른 패키지에 속해 있다면 다른 클래스와 이름이 동일하더라도 충돌이 발생하지 않는다.
  ( 서로 다른 폴더에는 이름이 같은 파일들이 존재할 수 있다.)


 3-1. 패키지 추가
  - 패키지 이름의 일반적인 정의 형식
	->  주로 회사 도메인 이름의 역순(codingbox.co.kr 회사 도메인 이면 -> kr.co.codingbox)
	프로젝트 이름의 소문자 (myapp)
	-> kr.co.codingbox.myapp.user
	-> kr.co.codingbox.myapp.shop
	-> kr.co.codingbox.myapp.password

 3-2. 복사된 소스파일 확인하기
  - 패키지에 소속된 클래스 파일은 첫 번째 라인에서 자신이 소속된 클래스 패키지 이름을 선언해야 한다.
  - 툴에서 왼쪽의 트리 영역에서 소스를 분류하는 작업을 통해 구문을 자동으로 추가해 주지만, 간혹 처리되지 않을때도 있으므로
  package 구문에서 에러가 발생할 경우 소스가 어떤 패키지에 있는지 확인하여 직접 이 구문을 수정해 주어야 한다.

4. ClassPath

  - 컴파일이 완료된 *.class 파일들이 위치하는 경로
  - ClassPath 를 컴파일시에 옵션으로 설정하면 그 안의 모든 클래스들을 참조할 수 있게 된다.
  - 즉 객체를 생성할 때 대상 클래스의 소스 없이도 컴파일된 결과물만 참조하여 객체 생성 및 메서드 호출 등이 가능해진다.

5. Library
  - 패키지와 클래스의 수가 점점 늘어남에 따라 전달해야 하는 파일의 수도 많아졌고, 매번 컴파일 결과물들을 압축해서 전달해야 했다.
  - 한 개 이상의 패키지들을 배포하기 용이하도록 압축한 형태
  - 다른 프로그램에서 라이브러리 안에 포함된 기능을 활용할 수 있다.
  - *.jar 
 

 6. Java 기본 API들
  - 우리가 사용하는 JDK 안에는 이미 수많은 라이브러리가 포함되어 있고, 이 라이브러리 안에는 프로그램 개발에 필요한 패키지들이
  기본적으로 포함되어 있다.
  - 자바 프로그래밍은 이러한 라이브러리들의 기능을 활용하여 이루어진다.
  - 이렇게 프로그램 개발을 위하여 기본적으로 제공되는 기능들을 API 라고 한다.







































